import mongoose, { Schema, Document, Model } from 'mongoose';
import bcrypt from 'bcryptjs';

export interface IUser extends Document {
  name: string;
  email: string;
  password: string;
  age?: number;
  gender?: string;
  occupation?: string;
  incomeRange?: string;
  accountNumber: string;
  balance: number;
  beneficiaries?: string[]; // Array of account numbers
  createdAt: Date;
  updatedAt: Date;
  comparePassword(candidatePassword: string): Promise<boolean>;
}

const UserSchema: Schema = new Schema(
  {
    name: {
      type: String,
      required: [true, 'Name is required'],
      trim: true,
    },
    email: {
      type: String,
      required: [true, 'Email is required'],
      unique: true,
      lowercase: true,
      trim: true,
      match: [/^\S+@\S+\.\S+$/, 'Please provide a valid email'],
    },
    password: {
      type: String,
      required: [true, 'Password is required'],
      minlength: 6,
    },
    age: {
      type: Number,
      min: [18, 'Age must be at least 18'],
      max: [120, 'Age must be less than 120'],
    },
    gender: {
      type: String,
      enum: ['Male', 'Female', 'Other'],
    },
    occupation: {
      type: String,
    },
    incomeRange: {
      type: String,
    },
    accountNumber: {
      type: String,
      unique: true,
      sparse: true, // Allow multiple null values for unique index
      required: false, // Explicitly set to false - will be auto-generated by pre-save hook
      default: undefined, // Use undefined instead of null for better Mongoose handling
    },
    balance: {
      type: Number,
      default: 10000, // Default balance of â‚¦10,000
      min: [0, 'Balance cannot be negative'],
    },
    beneficiaries: {
      type: [String],
      default: [],
    },
  },
  {
    timestamps: true,
  }
);

// Generate unique account number before saving (if not set)
// This MUST run before password hashing to ensure it's set before validation
UserSchema.pre<IUser>('save', async function (next) {
  // Only generate for new documents that don't have an account number
  // Check explicitly for undefined, null, or empty string
  const hasAccountNumber = this.accountNumber && 
    typeof this.accountNumber === 'string' && 
    this.accountNumber.trim() !== '';
  
  if (!this.isNew || hasAccountNumber) {
    return next();
  }
  
  const bankCode = process.env.NEXT_PUBLIC_BANK_CODE || 'BSA';
  let accountNumber: string = '';
  let exists = true;
  let attempts = 0;
  const maxAttempts = 10; // Prevent infinite loops
  
  const UserModel = this.constructor as Model<IUser>;
  
  while (exists && attempts < maxAttempts) {
    attempts++;
    // Generate 10-digit random number
    const randomNum = Math.floor(1000000000 + Math.random() * 9000000000);
    accountNumber = `${bankCode}-${randomNum}`;
    
    // Check if account number already exists
    try {
      const user = await UserModel.findOne({ accountNumber });
      exists = !!user;
    } catch (error) {
      // If error, assume it doesn't exist and break
      exists = false;
    }
  }
  
  if (!accountNumber) {
    return next(new Error('Failed to generate unique account number'));
  }
  
  this.accountNumber = accountNumber;
  next();
});

// Hash password before saving
UserSchema.pre<IUser>('save', async function (next) {
  if (!this.isModified('password')) return next();
  
  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
  next();
});

// Method to compare password
UserSchema.methods.comparePassword = async function (
  candidatePassword: string
): Promise<boolean> {
  return bcrypt.compare(candidatePassword, this.password);
};

// Clear any cached models to ensure schema changes take effect
delete mongoose.models.User;

const User: Model<IUser> = mongoose.model<IUser>('User', UserSchema);

export default User;
